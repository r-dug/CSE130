Lecture12CSE130CPP1IO
And.
 So.
 All right, let's get started.
 So we completed our C language sequence.
 Meaning now all of you are experienced programmers and C and you get to study your second language and you study it from the beginning.
 So it should be a lot easier second time around.
 You know the concepts.
 Now you're kind of just studying how to say it in a new language.
 You know why Ideas.
 It.
 Starts with kind of learning the basics and quickly will get into object oriented programing.
 And that's the interesting part of that language, that material for the course.
 Before I begin, do we have any questions? About anything.
 All right.
 So what makes it even easier is that the two languages are actually very closely related.
 I sometimes even failed to keep the lectures pure.
 I think I mix the C and C++ style comments.
 I use the strings in my examples of structures.
 So you know some C++ already.
 We did cover a lot of material, which is exactly the same.
 So, you know, a large portion of the language will concentrate on the parts which are new.
 Bit of a history of a language.
 Again, you don't have to memorize this chart.
 C++.
 As its roots and variants of C standardized C traditional C, which itself starts with language B.
 And before that they had ALGOL.
 The language was invented in 1979, which makes it just 44 years old now by Bjarne Stroustrup, who still actively contributes to developing it.
 Here is what a simple Hello World program looks like in C++.
 So you see some very familiar components.
 You see some things you haven't seen before.
 Today, we're going to make sure all those special symbols and key words make sense to you.
 So we still have the inclusion of libraries.
 LB include.
 The library looks slightly different and there is not a dot age at the end.
 There is something called namespace being utilized.
 The main function looks about the same returns and integer.
 And there is something called see out.
 Let's let's find out what those things are.
 C++ works with classes and objects, concepts we haven't covered yet.
 We will soon, but for now.
 As before, we'll just got to learn how to use them before we understand how they work fully.
 There is this idea of streams streams which bring data in, take data out, allow you to record what's happening in a program and we just need to learn to use different stream objects such as out and see.
 The streams are kind of generated by the system.
 You don't have to worry about actual connections, hardware, all that difficult stuff.
 You just need to learn how to utilize them.
 The two objects were particularly interested in seeing objects for reading data in and see out objects for writing data out.
 They are a part of standard namespace.
 Another concept we haven't looked at.
 We'll have a whole lecture devoted to the idea of namespaces.
 But for now we just utilize those objects to accomplish what we need.
 In this case, writing data to monitor.
 Those objects reside in the library, which is called AI or stream library input output stream.
 And for libraries which come with the language, we omit the dark age by convention.
 We just include the name of a library.
 Later on, we're going to learn how to create our own classes and you create a custom class.
 For that one, you would include fully qualified part of a file and call it something like IO stream dot h.
 So here I have an example where I'm trying to output some information to a monitor.
 The information is welcome to C++.
 You see that I rely on some keyboard, some objects as part of a standard library.
 See out and line and line is similar to backslash n from before.
 What is that prefix as the G.
 We talked about school before.
 One way to do limited scope is to create spaces with names.
 Maybe you working in a name space, you call my name space and within it you don't have to worry about conflicts between variable names.
 There is something called a standard name space where a lot of those objects exist defined to reside.
 But you notice it gets kind of old very quickly to always say.
 Standard namespace scope resolution operator, which is colon, colon and then object name.
 The prefix is always the same for the standard, right? So there is a way to avoid having it tried it out like as a long form by explicitly saying from now on, just assume I'm working with the standard namespace.
 One way to do it is to say using namespace name of the namespace.
 Once we do that, we can omit the prefix and just use the C out and C indirectly, which makes the code a lot neater.
 Easier to read.
 So here is a complete program.
 Using namespace standard.
 I have included my I stream library.
 I specified what namespace I'm working in and then I can just see out text to the monitor and see an information and the variables.
 Using see and and those interesting angular brackets we'll see more about them in a second will cover all the.
 And a missing information you have at this point.
 But anything I can answer at this point.
 Any questions? Yes.
 Is the intel portion required for this one or is it the same as.
 For the main function, you mean? Yes.
 Yeah.
 Like with all functions, you can have a function which returns nothing.
 I think it will be okay with you.
 Okay, well, let's see a few more slides, then it will start making more sense.
 So to get access to those objects and in general, then we work with classes to be able to, instance, instantiate objects, use objects.
 You have to include the name of the class.
 In this case, it's our string class.
 And then we already talked about the inclusion of a proper namespace.
 The class itself has a number of subclasses additional streams.
 There is an input stream and an output stream.
 And specifically I Airstream has two variables C and which is for common input encode which is used for common output.
 You saw those interesting angular brackets, those that extraction operator and insertion operator.
 They're going to give you the direction in which information flows and you can ask them to read or output multiple pieces of information.
 So I can, for example, see in data and a variable one, variable two and just nest them together.
 It is a binary operator.
 The left hand operator is an input stream variable such as C, and the right hand side is a variable of a simple data.
 So every time we have one of those extraction operators will read one item from the stream, depending on what data type we're reading into the data type of a variable on the right hand side, the actual information that that will change because different text corresponds to different amount of information and different data types will see an example of what that looks like and how to pass it.
 It's up to you to decide if you want to read one variable at a time on multiple reads together.
 Works the same way.
 Essentially, it reads through the information using wide spaces as separators.
 But it doesn't read the white space in terms of information skips it.
 So the information we scan in will be read and match the type of variable we're reading at the end of.
 If it's a character, then what is a single bit of information? Represent it as a symbol.
 If it's an integer, it reads as many digits as makes sense for an integer, and that is treated as an integer in general.
 For basic built in data types for character, we would read one printed character, one symbol.
 For end.
 We read a sequence of digits, possibly preceded by a sign positive for negative and for double.
 That is also in addition to the sign and digits, there is a decimal component to it.
 So your decimal number.
 So if we're editing a character, we'll skip all non printable information.
 And then after getting one symbol, the reading stops.
 For inside Davos.
 We read as long as the information still can be passed us that type of variable.
 So if it's an integer, we'll just keep reading digits until we were hit space or a non integer component.
 Non not a digit, not a period.
 At that point, we stop.
 If you are completely confused at this point.
 Let's look at an example that will clarify it and make a lot of sense to you.
 So I have generated some variables and B for integers, Z for double.
 And there are three character variables C, H, one and stage two.
 On the left side, I have a statement which will be executed.
 Their input is in the middle and then what actually gets extracted and stored and memories and the right.
 Some of those are pretty easy.
 If I'm doing a scene into a character, I'm giving a character.
 What gets stored in memory is a character.
 So no ambiguity, no confusion about passing.
 That's really the only option.
 If I have same input statement, but my input information is actually two characters in B.
 A get stored in character one after a single C and extraction and B is remaining in a buffer for future processing.
 So next time I'll do a read.
 There is that character B sitting there.
 Now next statement is see an end or a is an integer.
 The input is four eight, but we can read the whole thing as a single integer 48.
 So that gets stored in the next one.
 I'm still trying to read an integer, but the input looks to a human like a double.
 So what we're going to do is we're going to read all the all the digits we can salvage as an integer up to something which is not integer like looking component, which is in this case a period.
 So 46 get right, gets right and store it in the integer, and then dot 35 remains in the buffer for later processing.
 We're eating a Z, which is a double next.
 What looks like a double is provided.
 And so the whole thing gets absorbed in the Z.
 If we are expecting a double, but we are given what looks like an integer that's compatible.
 We're basically typecast and get 39.
0 instead of an integer, we get a double representation of the same.
 Now I can start mixing multiple inputs.
 So here I have seen a daisy, which is a double and then followed by a square.
 A read into an integer variable and input is a double looking thing.
 Space 38.
 So a Z reads as much of the input as possible to represent in that format a double.
 So we have digits, we have a decimal point, we have more digits all the way up to space.
 So that gets read as a double.
 And then after the space, the remaining component can be seen as an integer.
 So that gets completely absent.
 Any questions about that first set of examples? Yes.
 So white space is used as a separator if you're doing multiple inputs.
 Yeah.
 Okay, cool.
 See more examples.
 So you're starting to realize that based on a data type you expecting, you'll get a very different passing of the input.
 I start by looking for two integers.
 That's what I get.
 That's what I get to store in A and B.
 Now we have up to three reads A, which is the Jersey age, which is character, and finally Z, which is a double.
 So you get 57, followed by a space that could be stored as an integer.
 No problem.
 Capital A gets stored in the character.
 And then what's remaining is a double 26.
9.
 That input was nicely separated by spaces.
 So to a human, at least it wasn't very ambiguous.
 The next input for the same set of variables is just like that.
 But there is no space after a.
 Does it make a difference in this case? The second lead is a character.
 So I stop after reading one symbol, and what is left in the buffer is the same 26.
9.
 So if I have a structure to my expected data types, I can even admit separators because it's going to pass it based on the data we observe.
 Next input Likewise have has no spaces separating data types.
 So we're just reading as much as we can and it breaks down the same 57 capital.
 Only 6.
9.
 Now read We got Z, which is a double followed by a character followed by an integer.
 Start with a double.
 36.
78 is right.
 Then we're looking for a character.
 Finally, there is an integer.
 We can have more spaces, more unprintable characters.
 Doesn't make a difference.
 Same.
 Same passing will take place.
 If there is not enough input provided for the data types we're expecting to read, we'll just wait for additional information to be supplied.
 So either you have more data waiting in a buffer to be observed or you have see and waiting for more data to be provided if there is not enough in a buffer.
 Questions about this set of examples.
 So see, and we'll just read whatever input you give it until it's something that doesn't matter.
 Exactly.
 Yeah.
 But you can see how that could be ambiguous in some cases.
 You don't know if it should be split into symbol in an integer or a larger integer.
 So you want to be precise about how you specify your inputs.
 And I think we'll see some of those more challenging examples on the slide.
 So here I start with A and Z A is an integer.
 We get 46, then we have a double that gets 32.
4 in 68, sits in a buffer waiting to be processed.
 And Z.
 That's an interesting one.
 It looks like a double to a human right.
 But because we start with an integer read, we can read up to two digits here.
 So 78 gets read as an integer and bless you and Z gets the remainder from that which is.
 0.
49.
 Next example where input is just two, five, six, three digits.
 So it really matters in what order you try to read it, what characters are expected.
 If we start with c h we read to as a character and then it gets 56 as the remainder.
 In the next example, we switched the order.
 We start with an integer, so the whole thing gets right and there is nothing left for us to process.
 So now that is waiting for.
 And a B example is trivial.
 Any questions about that? Yeah.
 On the last statement, there was no bias.
 May be one.
 Still hold a few to still be read.
 What else would it be? If you're looking for one character, you're given one character.
 Yeah.
 All right.
 So we already used string data type as a native type and examples again and recovered structures, I believe.
 Here is the formal introduction to how to use it.
 There is a class library containing strings, so you have to include that.
 That gives you immediate access to being able to process strings.
 Strings.
 As you remember things in double quotes, there is no string, empty string.
 There is strings which contain different types.
 And if you need to have quotation marks within the string, you can have backslash quotation mark.
 To do that, there is a difference.
 We need to emphasize between null character.
 If you remember the null terminating character from our character array days in C and it's not the same as the empty string, they are just different concepts in how they're represented.
 So that's just a refresher on strings.
 Here's how you can easily work with strings for input and output.
 We need to include our stream for having access to see and and see out.
 We include string library to get access to strings.
 And now I can just create objects of a type string.
 In this case, string example.
 I can set it equal to this string literal today, Monday, and then I'll just see out my string directly as any other variable and I can follow it with end of the line.
 Everything else remains the same as before.
 Any questions about outputting strengths.
 Yup.
 So if you didn't want to add one, can you just get rid of the second to.
 Angular brackets and the inline just in that.
 Yeah, right.
 So you can ask those things as much as you want or shrink at Yeah.
 At any point.
 We can also read information into strings.
 So same setup, same libraries included.
 Still still using my standard namespace.
 I can create a new string variable, give it a default value to initialize it.
 Then I ask.
 What is your name as a prompt? That string gets outputted.
 Next I can read see in wood extraction operator whatever they provide into the name and output that name back two of them.
 So both reading and writing out strings quite easily supported.
 Here is an obvious example here I'm doing a little bit more with the numerical part of it, doing some mathematics as well.
 So I'm printing out my first C++ program, The sum of two of three is, and I'm outputting specific value for that.
 Or I can do seven plus eight equals and then put an equation in there and that gets evaluated before being printed.
 So maybe a little more intuitive and pleasant than print of skin off.
 The order of the day you output follows.
 What you see is what you get essentially.
 Any questions about that? So as I said, this is your second time taking a programing language.
 Now, this would be super easy.
 Just.
 Finding out how to do it in a different set of terms, the concepts, you know, what variables are, you know what strings are becomes a lot easier.
 Final example here.
 I'm just having a lot of inputs and outputs still include the same library.
 Still including namespace standard.
 I create variables of types integer float and double.
 I ask for input of an integer within an integer.
 I ask for.
 Variable.
 So which type? Float? Double.
 And then I read those in and finally I output all three variable types.
 You see, I can nest quite a few of those extraction separators.
 Extraction operators separated by spaces strings which are just string literals of space in quotes.
 So the digits would not be all combined together, but I would put it as three separate volumes.
 Any questions about that? All right.
 As I said, this is about 10% of what's there in the chapter because we know the rest.
 So that concludes its presentation.
 If you have any individual questions, please stop by and see me.
 